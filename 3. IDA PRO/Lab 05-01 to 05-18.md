## Lab 05-01 to 05-18

## 1. What is the address of DllMain?

The address of DllMain (known as DllEntryPoint) is at 0x1000D02E in .text section.

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/549ac794-d509-4e69-9a0f-c217eb6cf242)

## 2. Use the Imports window to browse to gethostbyname. Where is the import located?

Gethostbyname is located at 0x100163CC in .idata section.

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/980b14b8-42f9-4a37-b868-c75ba3b3c8f2)


## 3. How many functions call gethostbyname?

To find xrefs we need to select the gethostbyname and press ‘X’.

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/e0e58319-ba73-431f-88a3-461ec0944e4c)

Based on what we can see above we can tell that there are five unique functions that make a total number of 9 calls (it lists 18 because of different xref types (p and r).

## 4. Focusing on the call to gethostbyname located at 0x10001757, can you figure out which DNS request will be made?

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/1fb23c4f-2b3d-405b-a522-74d0bdc2d63d)

At location 0x10001757, we encounter a call to gethostbyname. A little earlier, at 0x1000174E, we observe that it initially moves a string from off_10019040 into the EAX register. Then, the pointer is incremented by 0xD (13 decimal), and the resulting value is pushed onto the stack before the call is made.

Following the pointer manipulation, it appears that the DNS being queried is **pics.practicalmalwareanalysis.com.**

## 5. How many local variables has IDA Pro recognized for the subroutine at 0x10001656?

The subroutine has exactly **23 variables** stated at the beginning.

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/22083291-942c-419e-8524-91cfa22c3d2f)

## 6. How many parameters has IDA Pro recognized for the subroutine at 0x10001656?

The IDA PRO has recognized one parameter called ‘lpThreadParameter’  stated at the beginning (look at image in task number 5).

## 7. Use the Strings window to locate the string \cmd.exe /c in the disassembly. Where is it located?

The ‘\cmd.exe /c’ string is found at xdoors_d section at memory location 0x10095B34.

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/1c687f25-103e-4ef5-9134-dc561cd48c23)

## 8. What is happening in the area of code that references \cmd.exe /c?

We have several functions calls made before the \cmd.exe /c, I will address them in the order of execution.

- CreatePipe – creates a handle to a process (parent/child),
- GetStartupInfoA – specifies the window station, desktop, standard handles, and appearance of the main window for a process at creation time,
- GetSystemDirectoryA - retrieves the path of the system directory.

After GetSystemDirectoryA call, it makes a cmp operation of dword_1008E5C4 with an ebx register. If the comparison is equal zero then it jumps to loc_100101D7 (0x 100101D7). This route leads to pushing a string "\\command.exe /c " into the stack.

If the comparison is not equal – it proceeds with next instruction which is pushing the string \cmd.exe /c in the stack.

From what I can deduce it checks for some gained information possibly about OS, then decides to run either command.exe /c or cmd.exe /c which in both cases executes given string via new console instance and then terminates itself.

## 9. In the same area, at 0x100101C8, it looks like dword_1008E5C4 is a global variable that helps decide which path to take. How does the malware set dword_1008E5C4? (Hint: Use dword_1008E5C4’s cross-references).

Okay, so this question is kinda going to be an answer with the previous one.

Dword_1008E5C4 is being compared with EAX register value, looking at XREF we find the moving the data into it from EAX, this is what we need.

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/c38b00c5-7aa7-401b-bd22-bbd4dea695b5)

Starting from the top, the code begins by adjusting stack pointer esp to allocate space for local variables, then it pushes registers onto the stack probably to save their values for later use. 

Later it calls the sub_10001000 which calls GetCurrentProcessId and pushes two strings depending on a jump: “rundll32.exe” and “rundll64.exe”. 

When the function ends, it makes sure if the eax value is equal to zero. If it is, then it continues with clearing ebx, and then calling sub_1003695, and this is what we need, lets look at it.

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/6521d405-a9c9-4cdf-bb83-e4156b23db10)

So in short words, the function checks for the OS information from GetVersionExA function.

It pushes the address of VersionInformation structure onto the stack as an argument for GetVersionExA function, then it compared dwPlatformId, the member of VersionInformation structure with the value 2.

Microsoft tell us what it means:

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/fe49cfa6-152b-4687-848a-5b8352174943)

So basically all it does is it compares if the platform is listed above and if it is then it sets Al register to 1, if it’s other platform than the ones listed above, then it sets Al to 0, then it returns to 0x10001678.

So after it returns, it sets the EAX value to dword_1008E5C4 which can be only 0 or 1 depending on the user OS.

## 10. A few hundred lines into the subroutine at 0x1000FF58, a series of comparisons use memcmp to compare strings. What happens if the string comparison to robotwork is successful (when memcmp returns 0)?

Memcmp function is used to compare two blocks of memory (Buf1 and Buf2) of a specified size. It returns an integer value depending of the contents of the two memory blocks.

In our code it does several comparisons using the said above memcmp, such as:

- quit
- exit
- cd
- :
- enmagic
- idle
- uptime
- language
- robotwork
- mbase
- mhost
- mmodule
- minstall
- inject

By looking at the graph I figured out that this is some kind of console application that gives the output based on the input, such as uptime, which results in providing for how much the machine has been running.

In this task we need to investigate the path of the successful result of string comparison of the input ‘robotwork’.

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/9839a189-e31c-4bb5-94c3-5acd1cda6ca1)

In loc_10010444  we have a memcmp call that compares a string “robotwork” with a buffer input value. The return value from memcmp is stored in EAX. If the result of test eax, eax is zero (the compared strings are equal) after that we can see that it pushes a handle to a socket onto the stack and then we see a call to sub_100052A2.

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/e854dc17-ef0d-4da4-ae17-d4626acacee5)

Function sub_100052A2 accepts one argument that is a socket handle (socket s).

It reserves a lot of space for variables and other data. 

At memory 0x100052F1 we can see a call ‘RegOpenKeyExA’ which opens specified registry key. It uses few parameters, which are declared earlier in the code. 

Let’s break them down:

LSTATUS RegOpenKeyExA(

`  `[in]           HKEY   hKey,

`  `[in, optional] LPCSTR lpSubKey,

`  `[in]           DWORD  ulOptions,

`  `[in]           REGSAM samDesired,

`  `[out]          PHKEY  phkResult

); 

hKey – a handle to open registry key.

lpSubKey – the name of the registry subkey to be opened, in our case it’s ‘SOFTWARE\Microsoft\Windows\CurrentVersion’

ulOptions – specifies option to apply when opening the key, in our case it’s 0, which doesn’t specify any additional options.

samDesired – mask that specifies desired access rights to the key to be opened. This application provides a mask with a value 0xF003F which corresponds to KEY_ALL_ACCESS (basically every right).

phkResult – pointer to variable that receives a handle to the opened key. In our case the EAX register holds the pointer.

If the call is successful (eax is zero), it proceeds to perform further operations which is jumping to loc_10005309. 

If the call fails, it closes the registry key and jumps to an error handling routine at loc_100053F6.

Let’s take a look at loc_10005309:

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/f099cd81-55e2-4a8f-968c-3c5395e9c360)

Inside loc_10005309 we can see that it pushes values for further RegQueryValueExA call to open a registry key called “WorkTime” and read its data. After it, it calls atoi to make sure the output data is an integer, then it pushes a string “Robot_WorkTime :”. When these two operations are made it calls sprintf to join them into one string that can be sent over a socket.

When we go back a little at 0x10005338 we can see text eax, eax. It does the same function as we saw in the function before. The software checks if the query went right. If it does not, then it jumps to loc_10005379 and proceeds to do the same, but with different registry key called “WorkTimes”. 

If it still fails, then the software closes the registry key and pops the registry values off the stack.

But if it succeeds then it also sends the gathered data through the socket. 

## 11. What does the export PSLIST do?

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/3f530f21-62e3-47a6-bc3f-2a5ce3a2c8d3)

The export PSLIST moves a value of 1 into dword_1008E5BC, then calls sub_100036C3.

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/deaddd68-110d-42cc-81f4-41ebffc57437)

Sub_100036C3 is intended to get information about OS version by using OSVERSIONINFOA structure and calling GetVersionExA function.

If the running OS is Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003, Windows XP, or Windows 2000 then it moves further, if not – terminate.  

At 0x100036EC it does another comparison, this time with version number, if the number if anything below 5 – then terminate. Microsoft documentation list any OS with a number below 5, so it just makes sure the application is not running on anything incompatible.

After the series of successful comparisons it pushes a value of 1 into the stack, then pops that value into eax register and returns to continue at 0x10007034.

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/cf90d830-94b8-4dc1-aa57-d4e1a13314af)

At 0x10007034 it checks if the value if non-zero (OS version XP or above) to proceed further at 0x1007038.

Later in the code it moves a Str pointer value that is on a stack, then it calls strlen to get the string length, which is later checked for being a zero. 

From now, we have two paths.

**Path no. 1. (If strlen value is zero then call sub_10006518)**

It calls CreateToolhelp32Snapshot to take a snapshot of processes. It moves through them using Process32First and Process32Next functions. In each process it uses EnumProcessModules and GetModuleFileNameExA to get information about them.

After it gets the information it calls sub_1000620C. In that subroutine it calls _vsnprintf, opens a file called “xinstall.dll” using fopen. If the operation is successful then it formats and writes a string using fprintf with “%s\n” where %s might be a placeholder for a string argument and \n is a newline character.

**Path no. 2. (if strlen value is non-zero, then call loc_1000704E -> call sub_1000664C with two arguments, the str and 0)**

This path is kinda similar to path 1, but this time it includes error handling, process information listing and sending the information via socket.

For process listing it also uses Process32First and Process32Next like before.

For information about processes – EnumProcessModules and GetModuleFileNameExA – exactly like before.

It lists processes with formatting: “\r\n\r\nProcessID       ProcessName”.

In the sub_100038BB we can see:

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/01c8c02f-8957-472a-b0f7-647f49243f0b)


This subroutine is intended to send the gathered information in file xinstall.dll to the malware author.

## 12. Use the graph mode to graph the cross-references from sub_10004E79. Which API functions could be called by entering this function? Based on the API functions alone, what could you rename this function?

Let’s take a look at sub_10004E79.

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/721f077c-173c-46f5-bafb-aae3b17cb615)


In the sub_10004E79 we can see two API calls:

- GetSystemDefaultLangID
- sprintf

Diving deeper we can find a call to sub_100038EE and there we have few more:

- malloc
- send
- free

Based on the API functions we can tell that first it prompts for information about default system language, then joins the strings with the output, allocates the memory and then sends it over the socket. We can call this function similar to the API function it calls first, like: GetSystemDefaultLanguage.


## 13. How many Windows API functions does DllMain call directly? How many at a depth of 2?

Depth 1:

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/19ea83ad-7961-48d9-973a-8761d5907001)

We can see that it directly calls strncpy, _strnicmp, CreateThread and strlen.

At depth 2 we have 28 unique calls.

## 14. At 0x10001358, there is a call to Sleep (an API function that takes one parameter containing the number of milliseconds to sleep). Looking backward through the code, how long will the program sleep if this code executes?

At 0x10001358 we can see:

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/dbdc8b12-03ab-43c4-98a3-e035858b7350)

Eax register takes a string “[This is CTI]30”, then it pushes hex D value which is 13 decimal. After moving further 13 characters we have a value 30.

Then it calls atoi to convert the string into integer and multiplies eax value (30) with 3E8 which is 1000 in decimal, and that results in 3000.

A sleep call takes one parameter which is calculated above (value 3000 miliseconds) and that 30 seconds.

## 15. At 0x10001701 is a call to socket. What are the three parameters?

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/f06c2ebd-86b7-4d35-bb71-a3e027572229)
![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/d937024b-fb37-4ba0-b4ff-430c78ad4b65)

Socket call takes three parameters:

- af - 2 
- type - 1
- protocol - 6

## 16. Using the MSDN page for socket and the named symbolic constants functionality in IDA Pro, can you make the parameters more meaningful?

- af (2) which is AF_INET (protocol version 4)
- type (1) which is SOCK_STREAM (sequenced, two-way)
- protocol (6) which is IPPROTO_TCP (transmission control protocol, requires af = AF_INET or AF_INET6 and type parameter of SOCK_STREAM.


## 17. Search for usage of the in instruction (opcode 0xED). This instruction is used with a magic string VMXh to perform VMware detection. Is that in use in this malware? Using the cross-references to the function that executes the in instruction, is there further evidence of VMware detection?

There is only one in instruction, and that is in 0x100061DB.

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/e6b6b2f4-910c-49ab-8ee0-e9a838326acb)

Let’s look at hex representation to see if there is a magic string “VMXh” that checks for VMware.

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/8bb52486-f438-4dc3-9841-d8fed06c74a5)

We can see ‘hXMV’ which in reverse order is: ‘VMXh’ and that is our sign of VMware detection. Let’s now take a look at cross-references of sub_10006196 to find more about it.

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/d24d5264-8c36-4fca-903f-5d555ae9d97e)


There are three calls to this function, each call is associated with VM detection purposes. For example InstallRT:

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/c926fac0-548d-43fb-94fe-fcf0b477a008)


## 18. Jump your cursor to 0x1001D988. What do you find?

At 0x1001D988 we can find a series of hexadecimal values that IDA PRO translates to:

![image](https://github.com/tomaszstopnicki/practical-malware-analysis-writeups/assets/163318997/4f62b1ad-e861-4b64-94cd-f63eb493f609)

These values doesn’t give me any hint of what it could be. It might be encoded. I don’t have.

Questions 19-21 are related to IDAPython which is included in IDA PRO version, unfortunately I do not have this version so I can’t answer the remaining questions.
